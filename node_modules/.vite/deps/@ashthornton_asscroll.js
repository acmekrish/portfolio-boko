import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/@ashthornton/asscroll/build/asscroll.js
var require_asscroll = __commonJS({
  "node_modules/@ashthornton/asscroll/build/asscroll.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["ASScroll"] = factory();
      else
        root["ASScroll"] = factory();
    })(self, function() {
      return function() {
        var __webpack_modules__ = {
          672: function(module2) {
            const store = {
              html: document.documentElement,
              body: document.body,
              window: {
                w: window.innerWidth,
                h: window.innerHeight
              }
            };
            module2.exports = store;
          },
          336: function(module2) {
            module2.exports = function debounce(fn, delay) {
              let timeoutID = null;
              return function() {
                clearTimeout(timeoutID);
                const args = arguments;
                const that = this;
                timeoutID = setTimeout(function() {
                  fn.apply(that, args);
                }, delay);
              };
            };
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        !function() {
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function() {
              return module2["default"];
            } : function() {
              return module2;
            };
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        }();
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        var __webpack_exports__ = {};
        !function() {
          "use strict";
          __webpack_require__.d(__webpack_exports__, {
            "default": function() {
              return src;
            }
          });
          var debounce = __webpack_require__(336);
          var debounce_default = __webpack_require__.n(debounce);
          var store = __webpack_require__(672);
          var store_default = __webpack_require__.n(store);
          ;
          function SelectorSet() {
            if (!(this instanceof SelectorSet)) {
              return new SelectorSet();
            }
            this.size = 0;
            this.uid = 0;
            this.selectors = [];
            this.selectorObjects = {};
            this.indexes = Object.create(this.indexes);
            this.activeIndexes = [];
          }
          var docElem = window.document.documentElement;
          var matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector;
          SelectorSet.prototype.matchesSelector = function(el, selector) {
            return matches.call(el, selector);
          };
          SelectorSet.prototype.querySelectorAll = function(selectors, context) {
            return context.querySelectorAll(selectors);
          };
          SelectorSet.prototype.indexes = [];
          var idRe = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
          SelectorSet.prototype.indexes.push({
            name: "ID",
            selector: function matchIdSelector(sel) {
              var m;
              if (m = sel.match(idRe)) {
                return m[0].slice(1);
              }
            },
            element: function getElementId(el) {
              if (el.id) {
                return [el.id];
              }
            }
          });
          var classRe = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
          SelectorSet.prototype.indexes.push({
            name: "CLASS",
            selector: function matchClassSelector(sel) {
              var m;
              if (m = sel.match(classRe)) {
                return m[0].slice(1);
              }
            },
            element: function getElementClassNames(el) {
              var className = el.className;
              if (className) {
                if (typeof className === "string") {
                  return className.split(/\s/);
                } else if (typeof className === "object" && "baseVal" in className) {
                  return className.baseVal.split(/\s/);
                }
              }
            }
          });
          var tagRe = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
          SelectorSet.prototype.indexes.push({
            name: "TAG",
            selector: function matchTagSelector(sel) {
              var m;
              if (m = sel.match(tagRe)) {
                return m[0].toUpperCase();
              }
            },
            element: function getElementTagName(el) {
              return [el.nodeName.toUpperCase()];
            }
          });
          SelectorSet.prototype.indexes["default"] = {
            name: "UNIVERSAL",
            selector: function() {
              return true;
            },
            element: function() {
              return [true];
            }
          };
          var Map;
          if (typeof window.Map === "function") {
            Map = window.Map;
          } else {
            Map = function() {
              function Map2() {
                this.map = {};
              }
              Map2.prototype.get = function(key) {
                return this.map[key + " "];
              };
              Map2.prototype.set = function(key, value) {
                this.map[key + " "] = value;
              };
              return Map2;
            }();
          }
          var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;
          function parseSelectorIndexes(allIndexes, selector) {
            allIndexes = allIndexes.slice(0).concat(allIndexes["default"]);
            var allIndexesLen = allIndexes.length, i, j, m, dup, rest = selector, key, index, indexes = [];
            do {
              chunker.exec("");
              if (m = chunker.exec(rest)) {
                rest = m[3];
                if (m[2] || !rest) {
                  for (i = 0; i < allIndexesLen; i++) {
                    index = allIndexes[i];
                    if (key = index.selector(m[1])) {
                      j = indexes.length;
                      dup = false;
                      while (j--) {
                        if (indexes[j].index === index && indexes[j].key === key) {
                          dup = true;
                          break;
                        }
                      }
                      if (!dup) {
                        indexes.push({ index, key });
                      }
                      break;
                    }
                  }
                }
              }
            } while (m);
            return indexes;
          }
          function findByPrototype(ary, proto) {
            var i, len, item;
            for (i = 0, len = ary.length; i < len; i++) {
              item = ary[i];
              if (proto.isPrototypeOf(item)) {
                return item;
              }
            }
          }
          SelectorSet.prototype.logDefaultIndexUsed = function() {
          };
          SelectorSet.prototype.add = function(selector, data) {
            var obj, i, indexProto, key, index, objs, selectorIndexes, selectorIndex, indexes = this.activeIndexes, selectors = this.selectors, selectorObjects = this.selectorObjects;
            if (typeof selector !== "string") {
              return;
            }
            obj = {
              id: this.uid++,
              selector,
              data
            };
            selectorObjects[obj.id] = obj;
            selectorIndexes = parseSelectorIndexes(this.indexes, selector);
            for (i = 0; i < selectorIndexes.length; i++) {
              selectorIndex = selectorIndexes[i];
              key = selectorIndex.key;
              indexProto = selectorIndex.index;
              index = findByPrototype(indexes, indexProto);
              if (!index) {
                index = Object.create(indexProto);
                index.map = new Map();
                indexes.push(index);
              }
              if (indexProto === this.indexes["default"]) {
                this.logDefaultIndexUsed(obj);
              }
              objs = index.map.get(key);
              if (!objs) {
                objs = [];
                index.map.set(key, objs);
              }
              objs.push(obj);
            }
            this.size++;
            selectors.push(selector);
          };
          SelectorSet.prototype.remove = function(selector, data) {
            if (typeof selector !== "string") {
              return;
            }
            var selectorIndexes, selectorIndex, i, j, k, selIndex, objs, obj, indexes = this.activeIndexes, selectors = this.selectors = [], selectorObjects = this.selectorObjects, removedIds = {}, removeAll = arguments.length === 1;
            selectorIndexes = parseSelectorIndexes(this.indexes, selector);
            for (i = 0; i < selectorIndexes.length; i++) {
              selectorIndex = selectorIndexes[i];
              j = indexes.length;
              while (j--) {
                selIndex = indexes[j];
                if (selectorIndex.index.isPrototypeOf(selIndex)) {
                  objs = selIndex.map.get(selectorIndex.key);
                  if (objs) {
                    k = objs.length;
                    while (k--) {
                      obj = objs[k];
                      if (obj.selector === selector && (removeAll || obj.data === data)) {
                        objs.splice(k, 1);
                        removedIds[obj.id] = true;
                      }
                    }
                  }
                  break;
                }
              }
            }
            for (i in removedIds) {
              delete selectorObjects[i];
              this.size--;
            }
            for (i in selectorObjects) {
              selectors.push(selectorObjects[i].selector);
            }
          };
          function sortById(a, b) {
            return a.id - b.id;
          }
          SelectorSet.prototype.queryAll = function(context) {
            if (!this.selectors.length) {
              return [];
            }
            var matches2 = {}, results = [];
            var els = this.querySelectorAll(this.selectors.join(", "), context);
            var i, j, len, len2, el, m, match, obj;
            for (i = 0, len = els.length; i < len; i++) {
              el = els[i];
              m = this.matches(el);
              for (j = 0, len2 = m.length; j < len2; j++) {
                obj = m[j];
                if (!matches2[obj.id]) {
                  match = {
                    id: obj.id,
                    selector: obj.selector,
                    data: obj.data,
                    elements: []
                  };
                  matches2[obj.id] = match;
                  results.push(match);
                } else {
                  match = matches2[obj.id];
                }
                match.elements.push(el);
              }
            }
            return results.sort(sortById);
          };
          SelectorSet.prototype.matches = function(el) {
            if (!el) {
              return [];
            }
            var i, j, k, len, len2, len3, index, keys, objs, obj, id;
            var indexes = this.activeIndexes, matchedIds = {}, matches2 = [];
            for (i = 0, len = indexes.length; i < len; i++) {
              index = indexes[i];
              keys = index.element(el);
              if (keys) {
                for (j = 0, len2 = keys.length; j < len2; j++) {
                  if (objs = index.map.get(keys[j])) {
                    for (k = 0, len3 = objs.length; k < len3; k++) {
                      obj = objs[k];
                      id = obj.id;
                      if (!matchedIds[id] && this.matchesSelector(el, obj.selector)) {
                        matchedIds[id] = true;
                        matches2.push(obj);
                      }
                    }
                  }
                }
              }
            }
            return matches2.sort(sortById);
          };
          ;
          const eventTypes = {};
          const listeners = {};
          const nonBubblers = ["mouseenter", "mouseleave", "pointerenter", "pointerleave"];
          function makeBusStack(event) {
            if (listeners[event] === void 0) {
              listeners[event] = [];
            }
          }
          function triggerBus(event, args) {
            if (listeners[event]) {
              for (let i = 0; i < listeners[event].length; i++) {
                listeners[event][i](...args);
              }
            }
          }
          function maybeRunQuerySelector(el) {
            return typeof el === "string" ? document.querySelectorAll(el) : el;
          }
          function handleDelegation(e) {
            let matches2 = traverse(eventTypes[e.type], e.target);
            if (matches2.length) {
              for (let i = 0; i < matches2.length; i++) {
                for (let i2 = 0; i2 < matches2[i].stack.length; i2++) {
                  if (nonBubblers.indexOf(e.type) !== -1) {
                    addDelegateTarget(e, matches2[i].delegatedTarget);
                    if (e.target === matches2[i].delegatedTarget) {
                      matches2[i].stack[i2].data(e);
                    }
                  } else {
                    addDelegateTarget(e, matches2[i].delegatedTarget);
                    matches2[i].stack[i2].data(e);
                  }
                }
              }
            }
          }
          function traverse(listeners2, target) {
            const queue = [];
            let node = target;
            do {
              if (node.nodeType !== 1) {
                break;
              }
              const matches2 = listeners2.matches(node);
              if (matches2.length) {
                queue.push({ delegatedTarget: node, stack: matches2 });
              }
            } while (node = node.parentElement);
            return queue;
          }
          function addDelegateTarget(event, delegatedTarget) {
            Object.defineProperty(event, "currentTarget", {
              configurable: true,
              enumerable: true,
              get: () => delegatedTarget
            });
          }
          function clone(object) {
            return JSON.parse(JSON.stringify(object));
          }
          ;
          class E {
            bindAll(context, methods) {
              if (!methods) {
                methods = Object.getOwnPropertyNames(Object.getPrototypeOf(context));
              }
              for (let i = 0; i < methods.length; i++) {
                context[methods[i]] = context[methods[i]].bind(context);
              }
            }
            on(event, el, callback, options) {
              const events = event.split(" ");
              for (let i = 0; i < events.length; i++) {
                if (typeof el === "function" && callback === void 0) {
                  makeBusStack(events[i]);
                  listeners[events[i]].push(el);
                  continue;
                }
                if (el.nodeType && el.nodeType === 1 || el === window || el === document) {
                  el.addEventListener(events[i], callback, options);
                  continue;
                }
                el = maybeRunQuerySelector(el);
                for (let n = 0; n < el.length; n++) {
                  el[n].addEventListener(events[i], callback, options);
                }
              }
            }
            delegate(event, delegate, callback) {
              const events = event.split(" ");
              for (let i = 0; i < events.length; i++) {
                let map = eventTypes[events[i]];
                if (map === void 0) {
                  map = new SelectorSet();
                  eventTypes[events[i]] = map;
                  if (nonBubblers.indexOf(events[i]) !== -1) {
                    document.addEventListener(events[i], handleDelegation, true);
                  } else {
                    document.addEventListener(events[i], handleDelegation);
                  }
                }
                map.add(delegate, callback);
              }
            }
            off(event, el, callback, options) {
              const events = event.split(" ");
              for (let i = 0; i < events.length; i++) {
                if (el === void 0) {
                  listeners[events[i]] = [];
                  continue;
                }
                if (typeof el === "function") {
                  makeBusStack(events[i]);
                  for (let n = 0; n < listeners[events[i]].length; n++) {
                    if (listeners[events[i]][n] === el) {
                      listeners[events[i]].splice(n, 1);
                    }
                  }
                  continue;
                }
                const map = eventTypes[events[i]];
                if (map !== void 0) {
                  map.remove(el, callback);
                  if (map.size === 0) {
                    delete eventTypes[events[i]];
                    if (nonBubblers.indexOf(events[i]) !== -1) {
                      document.removeEventListener(events[i], handleDelegation, true);
                    } else {
                      document.removeEventListener(events[i], handleDelegation);
                    }
                    continue;
                  }
                }
                if (el.removeEventListener !== void 0) {
                  el.removeEventListener(events[i], callback, options);
                  continue;
                }
                el = maybeRunQuerySelector(el);
                for (let n = 0; n < el.length; n++) {
                  el[n].removeEventListener(events[i], callback, options);
                }
              }
            }
            emit(event, ...args) {
              triggerBus(event, args);
            }
            debugDelegated() {
              return clone(eventTypes);
            }
            debugBus() {
              return clone(listeners);
            }
          }
          const instance = new E();
          var src_e = instance;
          ;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          class Events {
            constructor(options = {}) {
              _defineProperty(this, "onRaf", () => {
                src_e.emit(Events.INTERNALRAF);
                if (this.options.disableRaf)
                  return;
                requestAnimationFrame(this.onRaf);
              });
              this.options = options;
              this.addEvents();
            }
            addEvents() {
              if (!this.options.disableRaf) {
                requestAnimationFrame(this.onRaf);
              }
              if (!this.options.disableResize) {
                src_e.on("resize", window, debounce_default()(() => {
                  this.onResize();
                }, 150));
              }
              this.onScroll();
              if ("ontouchstart" in document.documentElement) {
                store_default().isTouch = true;
                this.detectMouse();
              }
            }
            onScroll() {
              src_e.on("wheel", window, (e) => {
                src_e.emit(Events.WHEEL, {
                  event: e
                });
              }, {
                passive: false
              });
              src_e.on("scroll", window, (e) => {
                src_e.emit(Events.INTERNALSCROLL, {
                  event: e
                });
              }, {
                passive: true
              });
            }
            onResize({
              width,
              height
            } = {}) {
              store_default().window.w = width || window.innerWidth;
              store_default().window.h = height || window.innerHeight;
              src_e.emit(Events.RESIZE);
            }
            detectMouse() {
              window.addEventListener("mousemove", function detectMouse(e) {
                if (Math.abs(e.movementX) > 0 || Math.abs(e.movementY) > 0) {
                  store_default().isTouch = false;
                  src_e.emit(Events.MOUSEDETECTED);
                  window.removeEventListener("mousemove", detectMouse);
                }
              });
            }
          }
          _defineProperty(Events, "INTERNALRAF", "raf:internal");
          _defineProperty(Events, "EXTERNALRAF", "raf:external");
          _defineProperty(Events, "WHEEL", "wheel");
          _defineProperty(Events, "INTERNALSCROLL", "scroll:internal");
          _defineProperty(Events, "EXTERNALSCROLL", "scroll:external");
          _defineProperty(Events, "RESIZE", "resize");
          _defineProperty(Events, "MOUSEDETECTED", "mouseDetected");
          _defineProperty(Events, "SCROLLEND", "scrollEnd");
          ;
          function Scrollbar_defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          class Scrollbar {
            constructor(controller) {
              Scrollbar_defineProperty(this, "onMouseMove", (e) => {
                if (!this.mouseDown)
                  return;
                this.mousePos = e.clientY;
                this.position -= this.prevMousePos - this.mousePos;
                this.position = Math.min(Math.max(this.position, 0), this.maxY);
                this.prevMousePos = this.mousePos;
                this.controller.targetPos = this.position / this.maxY * this.controller.maxScroll;
                this.controller.clamp();
                this.controller.syncScroll = true;
                this.transform();
                src_e.emit(Events.EXTERNALSCROLL, -this.controller.targetPos);
              });
              Scrollbar_defineProperty(this, "onMouseDown", (e) => {
                this.mousePos = this.prevMousePos = e.clientY;
                this.mouseDown = true;
                store_default().body.style.userSelect = "none";
                this.el.classList.add("active");
              });
              Scrollbar_defineProperty(this, "onMouseUp", () => {
                this.mouseDown = false;
                store_default().body.style.removeProperty("user-select");
                this.el.classList.remove("active");
              });
              this.controller = controller;
              this.addHTML();
              this.el = document.querySelector(this.controller.options.scrollbarEl);
              this.handle = document.querySelector(this.controller.options.scrollbarHandleEl);
              this.position = 0;
              this.mousePos = 0;
              this.prevMousePos = 0;
              this.addStyles();
              this.addEvents();
            }
            transform() {
              let y;
              if (this.mouseDown) {
                y = this.position;
              } else {
                y = -this.controller.targetPos / -this.controller.maxScroll * (store_default().window.h - this.handleHeight);
                this.position = y;
              }
              this.handle.style.transform = `translate3d(0, ${y}px, 0)`;
            }
            show() {
              this.el.classList.add("show");
            }
            hide() {
              this.el.classList.remove("show");
            }
            addEvents() {
              src_e.on("mousedown", this.handle, this.onMouseDown);
              src_e.on("mousemove", window, this.onMouseMove);
              src_e.on("mouseup", window, this.onMouseUp);
            }
            onResize() {
              this.scale = (-this.controller.maxScroll + store_default().window.h) / store_default().window.h;
              if (this.scale <= 1) {
                this.handle.style.height = 0;
                return;
              }
              this.trueSize = store_default().window.h / this.scale;
              this.handleHeight = Math.max(this.trueSize, 40);
              this.handle.style.height = `${this.handleHeight}px`;
              this.maxY = store_default().window.h - this.handleHeight;
            }
            addHTML() {
              if (document.querySelector(this.controller.options.scrollbarEl))
                return;
              const div = document.createElement("div");
              div.classList.add(this.controller.options.scrollbarEl.substring(1));
              div.innerHTML = `<div class="${this.controller.options.scrollbarHandleEl.substring(1)}"><div></div></div>`;
              document.body.appendChild(div);
            }
            addStyles() {
              if (!this.controller.options.disableNativeScrollbar && !this.controller.options.scrollbarStyles)
                return;
              let styles = "";
              if (this.controller.options.disableNativeScrollbar) {
                styles += `html{scrollbar-width:none;}body{-ms-overflow-style:none;}body::-webkit-scrollbar{width:0;height:0;}`;
              }
              if (this.controller.options.scrollbarStyles) {
                styles += `${this.controller.options.scrollbarEl} {position:fixed;top:0;right:0;width:20px;height:100%;z-index:900;}.is-touch ${this.controller.options.scrollbarEl} {display:none;}${this.controller.options.scrollbarEl} > div {padding:6px 0;width:10px;height:0;margin:0 auto;visibility:hidden;}${this.controller.options.scrollbarEl} > div > div {width:100%;height:100%;border-radius:10px;opacity:0.3;background-color:#000;}${this.controller.options.scrollbarEl} > div > div:hover {opacity:0.9;}${this.controller.options.scrollbarEl}:hover > div, ${this.controller.options.scrollbarEl}.show > div, ${this.controller.options.scrollbarEl}.active > div {visibility:visible;}${this.controller.options.scrollbarEl}.active > div > div {opacity:0.9;}`;
              }
              const css = document.createElement("style");
              if (css.styleSheet)
                css.styleSheet.cssText = styles;
              else
                css.appendChild(document.createTextNode(styles));
              document.getElementsByTagName("head")[0].appendChild(css);
            }
            destroy() {
              src_e.off("mousedown", this.handle, this.onMouseDown);
              src_e.off("mousemove", window, this.onMouseMove);
              src_e.off("mouseup", window, this.onMouseUp);
            }
          }
          ;
          function Controller_defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          class Controller {
            constructor(options = {}) {
              Controller_defineProperty(this, "onScroll", ({
                event
              }) => {
                if (!this.scrolling) {
                  this.toggleIframes();
                  this.scrolling = true;
                }
                const prevTargetPos = this.targetPos;
                if (!store_default().isTouch && event.type === "wheel") {
                  event.preventDefault();
                  this.syncScroll = true;
                  this.wheeling = true;
                  this.targetPos += event.deltaY * -1;
                } else {
                  if (this.preventResizeScroll) {
                    this.preventResizeScroll = false;
                    return;
                  }
                  if (this.wheeling) {
                    return;
                  }
                  if (store_default().isTouch && this.options.touchScrollType === "scrollTop") {
                    this.targetPos = this.horizontalScroll ? -this.containerElement.scrollLeft : -this.containerElement.scrollTop;
                  } else {
                    if (store_default().isTouch && this.options.touchScrollType === "transform" && this.options.lockIOSBrowserUI) {
                      this.targetPos = this.horizontalScroll ? -document.body.scrollLeft : -document.body.scrollTop;
                    } else {
                      this.targetPos = -window.scrollY;
                    }
                  }
                  if (store_default().isTouch && this.options.touchScrollType !== "transform") {
                    this.currentPos = this.targetPos;
                  }
                }
                this.clamp();
                if (prevTargetPos !== this.targetPos) {
                  src_e.emit(Events.EXTERNALSCROLL, -this.targetPos);
                  if (this.options.customScrollbar) {
                    this.scrollbar.show();
                  }
                }
                this.options.customScrollbar && this.scrollbar.transform();
              });
              Controller_defineProperty(this, "onRAF", () => {
                if (this.testFps && this.options.limitLerpRate) {
                  this.time = performance.now() * 1e-3;
                  this.delta = Math.min((this.time - this.startTime) * 60, 1);
                  this.startTime = this.time;
                }
                if (!this.render)
                  return;
                if (Math.abs(this.targetPos - this.currentPos) < 0.5) {
                  this.currentPos = this.targetPos;
                  if (this.scrolling && !this.syncScroll) {
                    this.scrolling = false;
                    this.options.customScrollbar && this.scrollbar.hide();
                    this.toggleIframes(true);
                    src_e.emit(Events.SCROLLEND, -this.targetPos);
                  }
                  if (this.syncScroll) {
                    window.scrollTo(0, -this.targetPos);
                    this.syncScroll = false;
                    this.wheeling = false;
                  }
                } else {
                  this.currentPos += (this.targetPos - this.currentPos) * this.ease * this.delta;
                }
                const x = this.horizontalScroll ? this.currentPos : 0;
                const y = this.horizontalScroll ? 0 : this.currentPos;
                this.applyTransform(x, y);
                src_e.emit(Events.EXTERNALRAF, {
                  targetPos: -this.targetPos,
                  currentPos: -this.currentPos
                });
              });
              Controller_defineProperty(this, "onResize", () => {
                if (this.scrollElementsLength > 1) {
                  const lastTarget = this.scrollElements[this.scrollElementsLength - 1];
                  const compStyle = window.getComputedStyle(lastTarget);
                  const marginOffset = parseFloat(this.horizontalScroll ? compStyle.marginRight : compStyle.marginBottom);
                  const bcr = lastTarget.getBoundingClientRect();
                  const endPosition = this.horizontalScroll ? bcr.right : bcr.bottom;
                  this.scrollLength = endPosition + marginOffset - this.currentPos;
                } else {
                  this.scrollLength = this.horizontalScroll ? this.scrollElements[0].scrollWidth : this.scrollElements[0].scrollHeight;
                }
                const windowSize = this.horizontalScroll ? store_default().window.w : store_default().window.h;
                this.maxScroll = this.scrollLength > windowSize ? -(this.scrollLength - windowSize) : 0;
                this.clamp();
                if (!this.firstResize) {
                  this.preventResizeScroll = true;
                }
                if (store_default().isTouch && this.options.lockIOSBrowserUI) {
                  this.containerElement.style.height = this.scrollLength + "px";
                } else {
                  store_default().body.style.height = this.scrollLength + "px";
                }
                this.options.customScrollbar && this.scrollbar.onResize();
                this.firstResize = false;
              });
              Controller_defineProperty(this, "toggleFixedContainer", () => {
                this.containerElement.style.position = "static";
                const scrollPos = this.currentPos;
                this.applyTransform(0, 0);
                requestAnimationFrame(() => {
                  this.containerElement.style.position = "fixed";
                  const x = this.horizontalScroll ? scrollPos : 0;
                  const y = this.horizontalScroll ? 0 : scrollPos;
                  this.applyTransform(x, y);
                });
              });
              this.options = options;
              this.targetPos = this.currentPos = this.prevScrollPos = this.maxScroll = 0;
              this.enabled = false;
              this.render = false;
              this.scrolling = false;
              this.wheeling = false;
              this.syncScroll = false;
              this.horizontalScroll = false;
              this.firstResize = true;
              this.preventResizeScroll = false;
              this.nativeScroll = true;
              this.ease = store_default().isTouch ? this.options.touchEase : this.options.ease;
              this.originalScrollbarSetting = this.options.customScrollbar;
              this.testFps = true;
              this.delta = 1;
              this.time = this.startTime = performance.now();
              this.setElements();
              if (store_default().isTouch) {
                this.options.customScrollbar = false;
                if (this.options.touchScrollType === "transform") {
                  this.setupSmoothScroll();
                } else if (this.options.touchScrollType === "scrollTop") {
                  document.documentElement.classList.add("asscroll-touch");
                  this.addTouchStyles();
                  src_e.on("scroll", this.containerElement, (e) => {
                    src_e.emit(Events.INTERNALSCROLL, {
                      event: e
                    });
                  }, {
                    passive: true
                  });
                }
              } else {
                this.setupSmoothScroll();
              }
              this.addEvents();
            }
            setElements() {
              this.containerElement = typeof this.options.containerElement === "string" ? document.querySelector(this.options.containerElement) : this.options.containerElement;
              if (this.containerElement === null) {
                console.error("ASScroll: could not find container element");
              }
              this.containerElement.setAttribute("asscroll-container", "");
              this.scrollElements = typeof this.options.scrollElements === "string" ? document.querySelectorAll(this.options.scrollElements) : this.options.scrollElements;
              if (this.scrollElements.length)
                this.scrollElements = [...this.scrollElements];
              this.scrollElements = this.scrollElements.length ? this.scrollElements : [this.containerElement.firstElementChild];
              this.scrollElementsLength = this.scrollElements.length;
              this.scrollElements.forEach((el) => el.setAttribute("asscroll", ""));
            }
            setupSmoothScroll() {
              this.nativeScroll = false;
              if (store_default().isTouch && this.options.lockIOSBrowserUI) {
                Object.assign(document.body.style, {
                  position: "fixed",
                  width: "100%",
                  height: "100%",
                  overflowY: "auto"
                });
                store_default().html.style.overflow = "hidden";
                this.scrollElements.forEach((el) => {
                  el.style.position = "fixed";
                });
                src_e.on("scroll", document.body, (e) => {
                  src_e.emit(Events.INTERNALSCROLL, {
                    event: e
                  });
                });
              } else {
                Object.assign(this.containerElement.style, {
                  position: "fixed",
                  top: "0px",
                  left: "0px",
                  width: "100%",
                  height: "100%",
                  contain: "content"
                });
              }
              if (this.options.customScrollbar) {
                this.scrollbar = new Scrollbar(this);
              }
              src_e.on(Events.INTERNALRAF, this.onRAF);
              src_e.on(Events.RESIZE, this.onResize);
              if (this.options.limitLerpRate) {
                setTimeout(() => {
                  this.testFps = false;
                  this.delta = Math.round(this.delta * 10) * 0.1;
                }, 2e3);
              }
            }
            applyTransform(x, y) {
              for (let i = 0; i < this.scrollElementsLength; i++) {
                this.scrollElements[i].style.transform = `translate3d(${x}px, ${y}px, 0px)`;
              }
            }
            enable({
              newScrollElements = false,
              reset = false,
              restore = false,
              horizontalScroll = false
            } = {}) {
              if (this.enabled)
                return;
              this.enabled = true;
              this.render = true;
              this.horizontalScroll = horizontalScroll;
              if (newScrollElements) {
                this.scrollElements = newScrollElements.length ? [...newScrollElements] : [newScrollElements];
                this.scrollElementsLength = this.scrollElements.length;
                this.scrollElements.forEach((el) => el.setAttribute("asscroll", ""));
                if (store_default().isTouch && this.options.touchScrollType === "transform" && this.options.lockIOSBrowserUI) {
                  this.scrollElements.forEach((el) => {
                    el.style.position = "fixed";
                  });
                }
              }
              this.iframes = this.containerElement.querySelectorAll("iframe");
              if (store_default().isTouch && this.options.touchScrollType !== "transform") {
                if (this.options.touchScrollType === "scrollTop") {
                  this.containerElement.style.removeProperty("overflow");
                }
                this.maxScroll = -this.containerElement.scrollHeight;
                if (reset) {
                  this.targetPos = this.currentPos = 0;
                  this.scrollTo(0, false);
                }
              } else {
                this.firstResize = true;
                if (reset) {
                  this.targetPos = this.currentPos = 0;
                  this.applyTransform(0, 0);
                }
                this.onResize();
              }
              if (store_default().isTouch && this.options.touchScrollType === "transform" && this.options.lockIOSBrowserUI) {
                store_default().body.style.overflowY = "auto";
                if (reset) {
                  document.body.scrollTo(0, 0);
                }
              }
              if (restore) {
                this.scrollTo(this.prevScrollPos, false);
              }
              src_e.on(Events.WHEEL, this.onScroll);
              src_e.on(Events.INTERNALSCROLL, this.onScroll);
            }
            disable({
              inputOnly = false
            } = {}) {
              if (!this.enabled)
                return;
              this.enabled = false;
              if (!inputOnly) {
                this.render = false;
              }
              src_e.off(Events.WHEEL, this.onScroll);
              src_e.off(Events.INTERNALSCROLL, this.onScroll);
              this.prevScrollPos = this.targetPos;
              if (store_default().isTouch) {
                if (this.options.touchScrollType === "scrollTop") {
                  this.containerElement.style.overflow = "hidden";
                } else if (this.options.touchScrollType === "transform" && this.options.lockIOSBrowserUI) {
                  store_default().body.style.overflowY = "hidden";
                }
              } else {
                store_default().body.style.height = "0px";
              }
            }
            clamp() {
              this.targetPos = Math.max(Math.min(this.targetPos, 0), this.maxScroll);
            }
            scrollTo(y, emitEvent = true) {
              this.targetPos = y;
              if (store_default().isTouch && this.options.touchScrollType !== "transform") {
                if (this.options.touchScrollType === "scrollTop") {
                  if (this.horizontalScroll) {
                    this.containerElement.scrollTo(-this.targetPos, 0);
                  } else {
                    this.containerElement.scrollTo(0, -this.targetPos);
                  }
                } else {
                  window.scrollTo(0, -this.targetPos);
                }
              }
              this.clamp();
              this.syncScroll = true;
              if (emitEvent)
                src_e.emit(Events.EXTERNALSCROLL, -this.targetPos);
            }
            toggleIframes(enable) {
              for (let i = 0; i < this.iframes.length; i++) {
                this.iframes[i].style.pointerEvents = enable ? "auto" : "none";
              }
            }
            blockScrollEvent(e) {
              e.stopPropagation();
            }
            addEvents() {
              src_e.on(Events.MOUSEDETECTED, () => {
                if (this.options.touchScrollType === "transform")
                  return;
                this.options.customScrollbar = this.originalScrollbarSetting;
                this.ease = this.options.ease;
                this.setupSmoothScroll();
                this.onResize();
              });
              if (!store_default().isTouch) {
                src_e.on("mouseleave", document, () => {
                  window.scrollTo(0, -this.targetPos);
                });
                src_e.on("keydown", window, (e) => {
                  if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "PageUp" || e.key === "PageDown" || e.key === "Home" || e.key === "End" || e.key === "Tab") {
                    window.scrollTo(0, -this.targetPos);
                  }
                  if (e.key === "Tab") {
                    this.toggleFixedContainer();
                  }
                });
                src_e.delegate("click", 'a[href^="#"]', this.toggleFixedContainer);
                src_e.delegate("wheel", this.options.blockScrollClass, this.blockScrollEvent);
              }
            }
            addTouchStyles() {
              const styles = `.asscroll-touch [asscroll-container] {position:absolute;top:0;left:0;right:0;bottom:-0.1px;overflow-y: auto;} .asscroll-touch [asscroll] {margin-bottom:0.1px;}`;
              const css = document.createElement("style");
              if (css.styleSheet)
                css.styleSheet.cssText = styles;
              else
                css.appendChild(document.createTextNode(styles));
              document.getElementsByTagName("head")[0].appendChild(css);
            }
          }
          ;
          function src_defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          class ASScroll {
            constructor(_parameters = {}) {
              src_defineProperty(this, "update", () => {
                this.events.onRaf();
              });
              src_defineProperty(this, "resize", (parameters) => {
                this.events.onResize(parameters);
              });
              const {
                containerElement = "[asscroll-container]",
                scrollElements = "[asscroll]",
                ease = 0.075,
                touchEase = 1,
                touchScrollType = "none",
                lockIOSBrowserUI = false,
                scrollbarEl = ".asscrollbar",
                scrollbarHandleEl = ".asscrollbar__handle",
                customScrollbar = true,
                scrollbarStyles = true,
                disableNativeScrollbar = true,
                disableRaf = false,
                disableResize = false,
                limitLerpRate = true,
                blockScrollClass = ".asscroll-block"
              } = _parameters;
              this.events = new Events({
                disableRaf,
                disableResize
              });
              this.controller = new Controller({
                containerElement,
                scrollElements,
                ease,
                touchEase,
                customScrollbar,
                lockIOSBrowserUI,
                scrollbarEl,
                scrollbarHandleEl,
                scrollbarStyles,
                disableNativeScrollbar,
                touchScrollType,
                limitLerpRate,
                blockScrollClass
              });
            }
            enable(parameters) {
              if (parameters !== void 0 && typeof parameters !== "object") {
                console.warn("ASScroll: Please pass an object with your parameters. Since 2.0");
              }
              this.controller.enable(parameters);
            }
            disable(parameters) {
              if (parameters !== void 0 && typeof parameters !== "object") {
                console.warn("ASScroll: Please pass an object with your parameters. Since 2.0");
              }
              this.controller.disable(parameters);
            }
            on(eventName, callback) {
              if (typeof callback !== "function") {
                console.error("ASScroll: Function not provided as second parameter");
                return;
              }
              if (eventName === "scroll") {
                src_e.on(Events.EXTERNALSCROLL, callback);
                return;
              }
              if (eventName === "update") {
                src_e.on(Events.EXTERNALRAF, callback);
                return;
              }
              if (eventName === "scrollEnd") {
                src_e.on(Events.SCROLLEND, callback);
                return;
              }
              console.warn(`ASScroll: "${eventName}" is not a valid event`);
            }
            off(eventName, callback) {
              if (typeof callback !== "function") {
                console.error("ASScroll: Function not provided as second parameter");
                return;
              }
              if (eventName === "scroll") {
                src_e.off(Events.EXTERNALSCROLL, callback);
                return;
              }
              if (eventName === "update") {
                src_e.off(Events.EXTERNALRAF, callback);
                return;
              }
              if (eventName === "scrollEnd") {
                src_e.off(Events.SCROLLEND, callback);
                return;
              }
              console.warn(`ASScroll: "${eventName}" is not a valid event`);
            }
            scrollTo(targetPos, emitEvent = true) {
              this.controller.scrollTo(-targetPos, emitEvent);
            }
            get targetPos() {
              return -this.controller.targetPos;
            }
            get currentPos() {
              return -this.controller.currentPos;
            }
            set currentPos(scrollPos) {
              this.controller.targetPos = this.controller.currentPos = -scrollPos;
            }
            get maxScroll() {
              return -this.controller.maxScroll;
            }
            get containerElement() {
              return this.controller.containerElement;
            }
            get scrollElements() {
              return this.controller.scrollElements;
            }
            get isHorizontal() {
              return this.controller.horizontalScroll;
            }
            get isScrollJacking() {
              return !this.controller.nativeScroll && this.controller.enabled;
            }
            get scrollPos() {
            }
            get smoothScrollPos() {
            }
            onRaf() {
            }
            onResize() {
            }
          }
          var src = ASScroll;
        }();
        __webpack_exports__ = __webpack_exports__.default;
        return __webpack_exports__;
      }();
    });
  }
});

// dep:@ashthornton_asscroll
var ashthornton_asscroll_default = require_asscroll();
export {
  ashthornton_asscroll_default as default
};
//# sourceMappingURL=@ashthornton_asscroll.js.map
